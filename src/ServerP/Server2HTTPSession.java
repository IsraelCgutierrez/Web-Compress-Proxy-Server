package ServerP;import java.io.BufferedOutputStream;import java.io.IOException;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;public class Server2HTTPSession extends Thread {	public static final int SC_OK = 0;	public static final int SC_CONNECTING_TO_HOST = 1;	public static final int SC_HOST_NOT_FOUND = 2;	public static final int SC_URL_BLOCKED = 3;	public static final int SC_CLIENT_ERROR = 4;	public static final int SC_INTERNAL_SERVER_ERROR = 5;	public static final int SC_NOT_SUPPORTED = 6;	public static final int SC_REMOTE_DEBUG_MODE = 7;	public static final int SC_CONNECTION_CLOSED = 8;	public static final int SC_HTTP_OPTIONS_THIS = 9;	public static final int SC_FILE_REQUEST = 10;	public static final int SC_MOVED_PERMANENTLY = 11;	public static final int SC_CONFIG_RQ = 12;	private static Server2Server server;	public InetAddress serveraddress;	/** downstream connections */	private Socket client;	private BufferedOutputStream out;	private Server2ClientInputStream in;	/** upstream connections */	private Socket HTTP_Socket;	private BufferedOutputStream HTTP_out;	private Server2ServerInputStream HTTP_in;	private final int ccc = 0;	public Server2HTTPSession(Server2Server server, Socket client) {		try {			in = new Server2ClientInputStream(server, this,					client.getInputStream());// ,true);			out = new BufferedOutputStream(client.getOutputStream());			Server2HTTPSession.server = server;			this.client = client;		} catch (IOException e_io) {			try {				client.close();			} catch (IOException e_io2) {			}			server.writeLog("Error while creating IO-Streams: " + e_io);			return;		}		try {			serveraddress = InetAddress.getLocalHost();		} catch (UnknownHostException e_u_host) {			server.writeLog("Can't get own server address! " + e_u_host);			return;		}		start();	}	public Socket getLocalSocket() {		return client;	}	public Socket getRemoteSocket() {		return HTTP_Socket;	}	public boolean isTunnel() {		return in.isTunnel();	}	public boolean notConnected() {		return HTTP_Socket == null;	}	public void sendHeader(int a, boolean b) throws IOException {		sendHeader(a);		endHeader();		out.flush();	}	public void sendHeader(int status, String content_type, long content_length)			throws IOException {		sendHeader(status);		sendLine("Content-Length", String.valueOf(content_length));		sendLine("Content-Type", content_type);	}	public void sendLine(String s) throws IOException {		write(out, s + "\r\n");	}	public void sendLine(String header, String s) throws IOException {		write(out, header + ": " + s + "\r\n");	}	public void endHeader() throws IOException {		write(out, "\r\n");	}	@Override	public void run() {		if (server.debug)			server.writeLog("begin http session");		server.increaseNumConnections();		try {			handleRequest();		} catch (IOException e_handleRequest) {			if (server.debug)				server.writeLog("run1: " + e_handleRequest.toString());		} catch (Exception e) {			e.printStackTrace();			server.writeLog("Server2HTTPSession.run(); " + e.getMessage());		}		try {			// close downstream connections			in.close();			out.close();			client.close();			// close upstream connections (webserver or other proxy)			if (!notConnected()) {				HTTP_Socket.close();				HTTP_out.close();				HTTP_in.close();			}		} catch (IOException e_run) {			if (server.debug)				server.writeLog("run2: " + e_run.getMessage());		}		server.decreaseNumConnections();		if (server.debug)			server.writeLog("end http session");	}	/** sends a message to the user */	public void sendErrorMSG(int a, String info) throws IOException {		String statuscode = sendHeader(a);		String localhost = "localhost";		try {			localhost = InetAddress.getLocalHost().getHostName() + ":"					+ server.port;		} catch (UnknownHostException e_unknown_host) {		}		String msg = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"><html>\r"				+ "<!-- Server2 error message --><HEAD>\r"				+ "<TITLE>"				+ statuscode				+ "</TITLE>\r"				// + "<link rel=\"stylesheet\" type=\"text/css\" href=\"http://"				// + localhost				// + "/style.css\"></HEAD>\r" // use css style sheet in htdocs				+ "<BODY BGCOLOR=\"#FFFFFF\" TEXT=\"#000000\" LINK=\"#000080\" VLINK=\"#000080\" ALINK=\"#000080\">\r"				+ "<h2 class=\"headline\">HTTP "				+ statuscode				+ " </h2>\r"				+ "<HR size=\"4\">\r"				+ "<p class=\"i30\">Your request for the following URL failed:</p>"				+ "<p class=\"tiagtext\"><a href=\""				+ in.getFullUrl()				+ "\">"				+ in.getFullUrl()				+ "</A> </p>\r"				+ "<P class=\"i25\">Reason: "				+ info + "</P>" + "</BODY></HTML>";		sendLine("Content-Length", String.valueOf(msg.length()));		sendLine("Content-Type", "text/html; charset=iso-8859-1");		endHeader();		write(out, msg);		out.flush();	}	public String sendHeader(int a) throws IOException {		String stat;		switch (a) {		case 200:			stat = "200 OK";			break;		case 202:			stat = "202 Accepted";			break;		case 300:			stat = "300 Ambiguous";			break;		case 301:			stat = "301 Moved Permanently";			break;		case 400:			stat = "400 Bad Request";			break;		case 401:			stat = "401 Denied";			break;		case 403:			stat = "403 Forbidden";			break;		case 404:			stat = "404 Not Found";			break;		case 405:			stat = "405 Bad Method";			break;		case 413:			stat = "413 Request Entity Too Large";			break;		case 415:			stat = "415 Unsupported Media";			break;		case 501:			stat = "501 Not Implemented";			break;		case 502:			stat = "502 Bad Gateway";			break;		case 504:			stat = "504 Gateway Timeout";			break;		case 505:			stat = "505 HTTP Version Not Supported";			break;		default:			stat = "500 Internal Server Error";		}		sendLine(server.getHttpVersion() + " " + stat);		sendLine("Server", server.getServerIdentification());		if (a == 501)			sendLine("Allow", "GET, HEAD, POST, PUT, DELETE, CONNECT");		sendLine("Cache-Control", "no-cache, must-revalidate");		sendLine("Connection", "close");		return stat;	}	/** the main routine, where it all happens */	public void handleRequest() throws Exception {		InetAddress remote_host;		Server2ReadI remote_in = null;		int remote_port;		byte[] b = new byte[65536];		int numread = in.read(b);		while (true) { // with this loop we support persistent connections			if (numread == -1) { // -1 signals an error				if (in.getStatusCode() != SC_CONNECTING_TO_HOST) {					switch (in.getStatusCode()) {					case SC_CONNECTION_CLOSED:						break;					case SC_CLIENT_ERROR:						sendErrorMSG(400,								"Your client sent a request that this proxy could not understand. ("										+ in.getErrorDescription() + ")");						break;					case SC_HOST_NOT_FOUND:						sendErrorMSG(								504,								"Host not found.<BR>Server2 was unable to resolve the hostname of this request. <BR>Perhaps the hostname was misspelled, the server is down or you have no connection to the internet.");						break;					case SC_INTERNAL_SERVER_ERROR:						sendErrorMSG(500,								"Server Error! (" + in.getErrorDescription()										+ ")");						break;					case SC_NOT_SUPPORTED:						sendErrorMSG(501,								"Your client used a HTTP method that this proxy doesn't support: ("										+ in.getErrorDescription() + ")");						break;					case SC_URL_BLOCKED:						sendErrorMSG(								403,								(in.getErrorDescription() != null										&& in.getErrorDescription().length() > 0 ? in										.getErrorDescription()										: "The request for this URL was denied by the Server2 URL-Filter."));						break;					// case SC_REMOTE_DEBUG_MODE: remoteDebug(); break;					case SC_HTTP_OPTIONS_THIS:						sendHeader(200);						endHeader();						break;					// case SC_HTTP_TRACE:					case SC_MOVED_PERMANENTLY:						sendHeader(301);						write(out, "Location: " + in.getErrorDescription()								+ "\r\n");						endHeader();						out.flush();					default:					}					break; // return from main loop.				} else { // also an error because we are not connected (or to							// the wrong host)							// Creates a new connection to a remote host.					if (!notConnected()) {						try {							HTTP_Socket.close();						} catch (IOException e_close_socket) {						}					}					numread = in.getHeaderLength(); // get the header length					if (!server.useProxy) {// sets up hostname and port						remote_host = in.getRemoteHost();						remote_port = in.remotePort;					} else {						remote_host = server.proxy;						remote_port = server.proxy_port;					}					// if (server.debug)server.writeLog("Connect: " +					// remote_host + ":" + remote_port);					try {						connect(remote_host, remote_port);					} catch (IOException e_connect) {						if (server.debug)							server.writeLog("handleRequest: "									+ e_connect.toString());						sendErrorMSG(								502,								"Error while creating a TCP connection to ["										+ remote_host.getHostName()										+ ":"										+ remote_port										+ "] <BR>The proxy server cannot connect to the given address or port ["										+ e_connect.toString() + "]");						break;					} catch (Exception e) {						server.writeLog("handleRequest: " + e.toString());						sendErrorMSG(500, "Error: " + e.toString());						break;					}					if (!in.isTunnel() || (in.isTunnel() && server.useProxy)) {						// no SSL-Tunnel or SSL-Tunnel with another remote						// proxy: simply forward the request						HTTP_out.write(in.a, 0, numread);						HTTP_out.flush();					} else {						// SSL-Tunnel with "CONNECT": creates a tunnel						// connection with the server						sendLine(server.getHttpVersion()								+ " 200 Connection established");						sendLine("Proxy-Agent",								server.getServerIdentification());						endHeader();						out.flush();					}					// read the data from the remote server					if (remote_in != null) {						remote_in.close(); // close Server2Read thread					}					remote_in = new Server2ReadI(server, this, HTTP_in, out, in);					// server.addBytesWritten(numread);				}			}			while (true) { // reads data from the client				// if (in.available() > 0 || ccc == 0) {				numread = in.read(b);				// if (server.debug)server.writeLog("Server2HTTPSession: " +				// numread + " Bytes read.");				if (numread != -1) {					if (numread > 0) {						HTTP_out.write(b, 0, numread);						HTTP_out.flush();						// server.addBytesWritten(numread);						numread = 0;						b = new byte[65536];						// ccc++;					}				} else {					break;				}				// } else if (in.available() == -1 || ccc > 100) {				// break;				// }			} // end of inner loop for data transfer		}// end of main loop		out.flush();		if (!notConnected() && remote_in != null)			remote_in.close(); // close Server2Read thread		return;	}	/** connects to the given host and port */	public void connect(InetAddress host, int port) throws IOException {		HTTP_Socket = new Socket(host, port);		HTTP_in = new Server2ServerInputStream(server, this,				HTTP_Socket.getInputStream(), false);		HTTP_out = new BufferedOutputStream(HTTP_Socket.getOutputStream());	}	/** converts a String into a Byte-Array to write it with the OutputStream */	public void write(BufferedOutputStream o, String p) throws IOException {		o.write(p.getBytes(), 0, p.length());	}	public int getStatus() {		return in.getStatusCode();	}}